{
  "error_handling_fix": true,
  "debug_payload": {
    "timestamp": "2026-02-12T02:11:00.000Z",
    "module": "src/services/technicals.js",
    "action": "command submitted",
    "command": "analyze(ticker)",
    "ticker": null,
    "bars": [],
    "technicals": null,
    "signals": null,
    "reason": "Insufficient data for indicators (prices, OHLCV) provided to computeTechnicals. Without at least 30 price bars or OHLCV bars, the technical engine cannot bootstrap required calculations (SMA, MACD, Bollinger Bands, etc.)."
  },
  "updated_file": "// src/services/technicals.js\nconst alpaca = require('./alpaca');\n\n/**\n * Technical Analysis Engine\n *\n * Ported from SHARK (https://github.com/ygwyg/SHARK)\n * Provides RSI, MACD, Bollinger Bands, SMA/EMA, ATR calculations\n * and automated signal detection (oversold/overbought, crossovers, etc.)\n *\n * All functions are pure math â€” no external API calls needed.\n * Feed them price bars from Alpaca, Yahoo, or any OHLCV source.\n */\n\nconst alpaca = require('./alpaca');\n\n// â”€â”€ Core Indicators â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€\n\n/**\n * Simple Moving Average\n * @param {number[]} prices - array of prices (oldest first)\n * @param {number} period\n * @returns {number|null}\n */\nfunction calculateSMA(prices, period) {\n  if (prices.length < period) {\n    console.log('[DEBUG] calculateSMA called with insufficient price data', {\n      prices_length: prices.length,\n      required_period: period,\n      error_type: 'INPUT_TOO_SHORT',\n      timestamp: new Date().toISOString()\n    });\n    return null;\n  }\n  const slice = prices.slice(-period);\n  return slice.reduce((a, b) => a + b, 0) / period;\n}\n\n/**\n * Exponential Moving Average\n * @param {number[]} prices\n * @param {number} period\n * @returns {number|null}\n */\nfunction calculateEMA(prices, period) {\n  if (prices.length < period) {\n    console.log('[DEBUG] calculateEMA called with insufficient price data', {\n      prices_length: prices.length,\n      required_period: period,\n      error_type: 'INPUT_TOO_SHORT',\n      timestamp: new Date().toISOString()\n    });\n    return null;\n  }\n  const multiplier = 2 / (period + 1);\n  let ema = prices.slice(0, period).reduce((a, b) => a + b, 0) / period;\n  for (let i = period; i < prices.length; i++) {\n    ema = (prices[i] - ema) * multiplier + ema;\n  }\n  return ema;\n}\n\n/**\n * Relative Strength Index (Wilder's smoothing)\n * @param {number[]} prices\n * @param {number} period - default 14\n * @returns {number|null}\n */\nfunction calculateRSI(prices, period = 14) {\n  if (prices.length < period + 1) {\n    console.log('[DEBUG] calculateRSI called with insufficient price data', {\n      prices_length: prices.length,\n      required_period: period + 1,\n      error_type: 'INPUT_TOO_SHORT',\n      timestamp: new Date().toISOString()\n    });\n    return null;\n  }\n  const changes = [];\n  for (let i = 1; i < prices.length; i++) {\n    changes.push(prices[i] - prices[i - 1]);\n  }\n  const gains = changes.map(c => (c > 0 ? c : 0));\n  const losses = changes.map(c => (c < 0 ? -c : 0));\n\n  let avgGain = gains.slice(0, period).reduce((a, b) => a + b, 0) / period;\n  let avgLoss = losses.slice(0, period).reduce((a, b) => a + b, 0) / period;\n  for (let i = period; i < changes.length; i++) {\n    avgGain = (avgGain * (period - 1) + gains[i]) / period;\n    avgLoss = (avgLoss * (period - 1) + losses[i]) / period;\n  }\n\n  if (avgLoss === 0) return 100;\n  const rs = avgGain / avgLoss;\n  return 100 - 100 / (1 + rs);\n}\n\n/**\n * MACD (12/26/9)\n * @param {number[]} prices\n * @returns {{ macd: number, signal: number, histogram: number }|null}\n */\nfunction calculateMACD(prices) {\n  const ema12 = calculateEMA(prices, 12);\n  const ema26 = calculateEMA(prices, 26);\n  if (ema12 === null || ema26 === null) {\n    console.log('[DEBUG] calculateMACD returned null due to missing EMA12 or EMA26 values', {\n      ema12_provided: ema12 !== null,\n      ema26_provided: ema26 !== null,\n      timestamp: new Date().toISOString()\n    });\n    return null;\n  }\n  const macdLine = ema12 - ema26;\n\n  // Recompute intermediate MACD values for signal line\n  const macdValues = [];\n  let tempEma12 = prices.slice(0, 12).reduce((a, b) => a + b, 0) / 12;\n  let tempEma26 = prices.slice(0, 26).reduce((a, b) => a + b, 0) / 26;\n  for (let i = 26; i < prices.length; i++) {\n    tempEma12 = (prices[i] - tempEma12) * (2 / 13) + tempEma12;\n    tempEma26 = (prices[i] - tempEma26) * (2 / 27) + tempEma26;\n    macdValues.push(tempEma12 - tempEma26);\n  }\n  if (macdValues.length < 9) {\n    console.log('[DEBUG] calculateMACD signal line computation failed due to insufficient MACD values', {\n      macdValues_length: macdValues.length,\n      required_minimum: 9,\n      timestamp: new Date().toISOString()\n    });\n    return null; // <-- early exit if insufficient values\n  }\n\n  // Signal line = 9-period EMA of MACD values\n  let signal = macdValues.slice(0, 9).reduce((a, b) => a + b, 0) / 9;\n  for (let i = 9; i < macdValues.length; i++) {\n    signal = (macdValues[i] - signal) * (2 / 10) + signal;\n  }\n  return { macd: macdLine, signal, histogram: macdLine - signal };\n}\n\n/**\n * Bollinger Bands (20-period, 2 std dev)\n * @param {number[]} prices\n * @param {number} period\n * @param {number} stdDev\n * @returns {{ upper: number, middle: number, lower: number, width: number }|null}\n */\nfunction calculateBollingerBands(prices, period = 20, stdDev = 2) {\n  if (prices.length < period) {\n    console.log('[DEBUG] calculateBollingerBands called with insufficient price data', {\n      prices_length: prices.length,\n      required_period: period,\n      error_type: 'INPUT_TOO_SHORT',\n      timestamp: new Date().toISOString()\n    });\n    return null;\n  }\n  const slice = prices.slice(-period);\n  const middle = slice.reduce((a, b) => a + b, 0) / period;\n  const squaredDiffs = slice.map(p => (p - middle) ** 2);\n  const variance = squaredDiffs.reduce((a, b) => a + b, 0) / period;\n  const std = Math.sqrt(variance);\n  const upper = middle + stdDev * std;\n  const lower = middle - stdDev * std;\n  return { upper, middle, lower, width: (upper - lower) / middle };\n}\n\n/**\n * Average True Range (requires OHLCV bars)\n * @param {Array<{h: number, l: number, c: number}>} bars\n * @param {number} period\n * @returns {number|null}\n */\nfunction calculateATR(bars, period = 14) {\n  if (bars.length < period + 1) {\n    console.log('[DEBUG] calculateATR called with insufficient OHLCV bars', {\n      bars_length: bars.length,\n      required_period: period + 1,\n      error_type: 'INPUT_TOO_SHORT',\n      timestamp: new Date().toISOString()\n    });\n    return null;\n  }\n  const trueRanges = [];\n  for (let i = 1; i < bars.length; i++) {\n    const current = bars[i];\n    const prev = bars[i - 1];\n    const tr = Math.max(\n      current.h - current.l,\n      Math.abs(current.h - prev.c),\n      Math.abs(current.l - prev.c)\n    );\n    trueRanges.push(tr);\n  }\n  if (trueRanges.length < period) {\n    console.log('[DEBUG] calculateATR returned null due to insufficient TR values', {\n      true_ranges_length: trueRanges.length,\n      required_period: period,\n      error_type: 'INPUT_TOO_SHORT',\n      timestamp: new Date().toISOString()\n    });\n    return null;\n  }\n\n  let atr = trueRanges.slice(0, period).reduce((a, b) => a + b, 0) / period;\n  for (let i = period; i < trueRanges.length; i++) {\n    atr = (atr * (period - 1) + trueRanges[i]) / period;\n  }\n  return atr;\n}\n\n// â”€â”€ Compute all indicators at once â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€\n\n/**\n * Compute full technical analysis from OHLCV bars.\n * @param {string} symbol\n * @param {Array<{t: string, o: number, h: number, l: number, c: number, v: number}>} bars\n * @returns {object} TechnicalIndicators\n */\nfunction computeTechnicals(symbol, bars) {\n  if (!bars || bars.length === 0) {\n    console.log('[DEBUG] computeTechnicals invoked with empty bars array', {\n      symbol,\n      bars_length: bars?.length || 0,\n      timestamp: new Date().toISOString()\n    });\n    throw new Error('No price bars provided to computeTechnicals');\n  }\n  const closes = bars.map(b => b.c);\n  const volumes = bars.map(b => b.v);\n  const currentPrice = closes[closes.length - 1] ?? 0;\n  const currentVolume = volumes[volumes.length - 1] ?? 0;\n  const volumeSma = calculateSMA(volumes, 20);\n  const relativeVolume = volumeSma && volumeSma > 0 ? currentVolume / volumeSma : null;\n\n  return {\n    symbol,\n    timestamp: bars[bars.length - 1]?.t ?? new Date().toISOString(),\n    price: currentPrice,\n    sma_20: calculateSMA(closes, 20),\n    sma_50: calculateSMA(closes, 50),\n    sma_200: calculateSMA(closes, 200),\n    ema_12: calculateEMA(closes, 12),\n    ema_26: calculateEMA(closes, 26),\n    rsi_14: calculateRSI(closes, 14),\n    macd: calculateMACD(closes),\n    bollinger: calculateBollingerBands(closes, 20, 2),\n    atr_14: calculateATR(bars, 14),\n    volume_sma_20: volumeSma,\n    relative_volume: relativeVolume,\n  };\n}\n\n// â”€â”€ Signal Detection â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€\n\n/**\n * Detect actionable trading signals from technical indicators.\n * @param {object} tech - output from computeTechnicals()\n * @returns {Array<{type: string, direction: string, strength: number, description: string}>}\n */\nfunction detectSignals(tech) {\n  if (!tech) {\n    console.log('[DEBUG] detectSignals received undefined technicals object', {\n      tech_input: tech,\n      timestamp: new Date().toISOString()\n    });\n    return [];\n  }\n\n  const signals = [];\n\n  // RSI oversold / overbought\n  if (tech.rsi_14 !== null) {\n    if (tech.rsi_14 < 30) {\n      signals.push({\n        type: 'rsi_oversold', direction: 'bullish',\n        strength: (30 - tech.rsi_14) / 30,\n        description: `RSI at ${tech.rsi_14.toFixed(1)} â€” oversold territory`,\n      });\n    } else if (tech.rsi_14 > 70) {\n      signals.push({\n        type: 'rsi_overbought', direction: 'bearish',\n        strength: (tech.rsi_14 - 70) / 30,\n        description: `RSI at ${tech.rsi_14.toFixed(1)} â€” overbought territory`,\n      });\n    }\n  } else {\n    console.log('[DEBUG] detectSignals skipped RSI because tech.rsi_14 is null', {\n      rsi_value: tech.rsi_14,\n      timestamp: new Date().toISOString()\n    });\n  }\n\n  // MACD crossover\n  if (tech.macd !== null) {\n    if (tech.macd.histogram > 0 && tech.macd.macd > tech.macd.signal) {\n      signals.push({\n        type: 'macd_bullish', direction: 'bullish',\n        strength: Math.min(1, Math.abs(tech.macd.histogram) * 10),\n        description: 'MACD above signal line â€” bullish momentum',\n      });\n    } else if (tech.macd.histogram < 0 && tech.macd.macd < tech.macd.signal) {\n      signals.push({\n        type: 'macd_bearish', direction: 'bearish',\n        strength: Math.min(1, Math.abs(tech.macd.histogram) * 10),\n        description: 'MACD below signal line â€” bearish momentum',\n      });\n    }\n  } else {\n    console.log('[DEBUG] detectSignals skipped MACD because tech.macd is null', {\n      macd: tech.macd,\n      timestamp: new Date().toISOString()\n    });\n  }\n\n  // Bollinger Band position\n  if (tech.bollinger !== null) {\n    const bbPos = (tech.price - tech.bollinger.lower) / (tech.bollinger.upper - tech.bollinger.lower);\n    if (bbPos < 0.1) {\n      signals.push({\n        type: 'bb_lower_touch', direction: 'bullish',\n        strength: 1 - bbPos * 10,\n        description: 'Price near lower Bollinger Band â€” potential bounce',\n      });\n    } else if (bbPos > 0.9) {\n      signals.push({\n        type: 'bb_upper_touch', direction: 'bearish',\n        strength: (bbPos - 0.9) * 10,\n        description: 'Price near upper Bollinger Band â€” potential pullback',\n      });\n    }\n  } else {\n    console.log('[DEBUG] detectSignals skipped Bollinger Bands because tech.bollinger is null', {\n      bollinger: tech.bollinger,\n      timestamp: new Date().toISOString()\n    });\n  }\n\n  // SMA cross (20 vs 50)\n  if (tech.sma_20 !== null && tech.sma_50 !== null) {\n    const crossStrength = Math.abs(tech.sma_20 - tech.sma_50) / tech.price;\n    if (tech.sma_20 > tech.sma_50) {\n      signals.push({\n        type: 'golden_cross_active', direction: 'bullish',\n        strength: Math.min(1, crossStrength * 20),\n        description: '20 SMA above 50 SMA â€” bullish trend',\n      });\n    } else {\n      signals.push({\n        type: 'death_cross_active', direction: 'bearish',\n        strength: Math.min(1, crossStrength * 20),\n        description: '20 SMA below 50 SMA â€” bearish trend',\n      });\n    }\n  } else {\n    console.log('[DEBUG] detectSignals skipped SMA cross because tech.sma_20 or tech.sma_50 is null', {\n      sma_20: tech.sma_20,\n      sma_50: tech.sma_50,\n      timestamp: new Date().toISOString()\n    });\n  }\n\n  // Price vs 200 SMA (trend filter)\n  if (tech.sma_200 !== null) {\n    if (tech.price > tech.sma_200) {\n      signals.push({\n        type: 'above_200sma', direction: 'bullish',\n        strength: Math.min(1, ((tech.price - tech.sma_200) / tech.sma_200) * 10),\n        description: `Price above 200 SMA â€” long-term uptrend`,\n      });\n    } else {\n      signals.push({\n        type: 'below_200sma', direction: 'bearish',\n        strength: Math.min(1, ((tech.sma_200 - tech.price) / tech.sma_200) * 10),\n        description: `Price below 200 SMA â€” long-term downtrend`,\n      });\n    }\n  } else {\n    console.log('[DEBUG] detectSignals skipped 200 SMA because tech.sma_200 is null', {\n      sma_200: tech.sma_200,\n      timestamp: new Date().toISOString()\n    });\n  }\n\n  // Unusual volume\n  if (tech.relative_volume !== null && tech.relative_volume > 2) {\n    signals.push({\n      type: 'high_volume', direction: 'neutral',\n      strength: Math.min(1, (tech.relative_volume - 1) / 4),\n      description: `Volume ${tech.relative_volume.toFixed(1)}x average â€” unusual activity`,\n    });\n  } else {\n    console.log('[DEBUG] detectSignals skipped volume check because tech.relative_volume is null or <= 2', {\n      relative_volume: tech.relative_volume,\n      timestamp: new Date().toISOString()\n    });\n  }\n\n  return signals;\n}\n\n// â”€â”€ High-level analysis (fetches data + computes) â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€-\n\n/**\n * Run full technical analysis for a ticker.\n * Fetches 200 days of bars from Alpaca (or Yahoo fallback), then computes all indicators.\n *\n * @param {string} ticker\n * @returns {{ technicals: object, signals: Array, bars: Array }}\n */\nasync function analyze(ticker) {\n  const upper = ticker.toUpperCase();\n  let bars;\n\n  // Try Alpaca first (better data quality)\n  if (alpaca.enabled) {\n    try {\n      const raw = await alpaca.getHistory(upper, 250);\n      bars = raw.map(b => ({\n        t: b.date,\n        o: b.open,\n        h: b.high,\n        l: b.low,\n        c: b.close,\n        v: b.volume,\n      }));\n    } catch (err) {\n      console.warn(`[Technicals] Alpaca bars failed for ${upper}: ${err.message}`);\n    }\n  }\n\n  // Fallback: Yahoo Finance via existing service\n  if (!bars || bars.length < 30) {\n    try {\n      const yahoo = require('./yahoo');\n      const snapshot = await yahoo.getTickerSnapshot(upper);\n      if (snapshot?.history?.length > 0) {\n        bars = snapshot.history.map(b => ({\n          t: b.date,\n          o: b.open,\n          h: b.high,\n          l: b.low,\n          c: b.close,\n          v: b.volume,\n        }));\n      }\n    } catch (err) {\n      console.warn(`[Technicals] Yahoo bars failed for ${upper}: ${err.message}`);\n    }\n  }\n\n  if (!bars || bars.length < 30) {\n    throw new Error(`Not enough price history for ${upper} (need 30+ bars, got ${bars?.length || 0})`);\n  }\n\n  const technicals = computeTechnicals(upper, bars);\n  const signals = detectSignals(technicals);\n\n  return { technicals, signals, bars };\n}\n\n// â”€â”€ Discord formatting â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€\n\n/**\n * Format technical analysis for Discord.\n * @param {object} result - from analyze()\n * @returns {string}\n */\nfunction formatForDiscord(result) {\n  const { technicals: t, signals } = result;\n  const fmt = (v) => v !== null && v !== undefined ? v.toFixed(2) : 'â€”';\n\n  const lines = [\n    `**${t.symbol} â€” Technical Analysis**`,\n    `Price: \`$${fmt(t.price)}\` | Time: \`${new Date(t.timestamp).toLocaleDateString()}\``,\n    ``,\n    `**Moving Averages**`,\n    `SMA 20: \`$${fmt(t.sma_20)}\` | SMA 50: \`$${fmt(t.sma_50)}\` | SMA 200: \`$${fmt(t.sma_200)}\``,\n    `EMA 12: \`$${fmt(t.ema_12)}\` | EMA 26: \`$${fmt(t.ema_26)}\``,\n    ``,\n    `**Momentum**`,\n    `RSI(14): \`${fmt(t.rsi_14)}\`${t.rsi_14 !== null ? (t.rsi_14 < 30 ? ' (oversold)' : t.rsi_14 > 70 ? ' (overbought)' : '') : ''}`,\n  ];\n\n  if (t.macd) {\n    lines.push(`MACD: \`${fmt(t.macd.macd)}\` | Signal: \`${fmt(t.macd.signal)}\` | Hist: \`${fmt(t.macd.histogram)}\``);\n  } else {\n    lines.push(`MACD: \`â€”\``);\n  }\n\n  lines.push(``);\n  lines.push(`**Volatility**`);\n  if (t.bollinger) {\n    lines.push(`Bollinger: \`$${fmt(t.bollinger.lower)}\` â€” \`$${fmt(t.bollinger.middle)}\` â€” \`$${fmt(t.bollinger.upper)}\` (width: ${(t.bollinger.width * 100).toFixed(1)}%)`);\n  }\n  lines.push(`ATR(14): \`$${fmt(t.atr_14)}\``);\n\n  if (t.relative_volume !== null) {\n    lines.push(`Relative Volume: \`${t.relative_volume.toFixed(1)}x\` avg`);\n  }\n\n  // Signals\n  if (signals.length > 0) {\n    lines.push(``);\n    lines.push(`**Signals Detected**`);\n    for (const sig of signals) {\n      const emoji = sig.direction === 'bullish' ? 'ðŸŸ¢' : sig.direction === 'bearish' ? 'ðŸ”´' : 'ðŸŸ¡';\n      const bar = 'â–ˆ'.repeat(Math.round(sig.strength * 5)) + 'â–‘'.repeat(5 - Math.round(sig.strength * 5));\n      lines.push(`${emoji} ${sig.description} [${bar}]`);\n    }\n  } else {\n    lines.push(``);\n    lines.push(`_No strong signals detected â€” consolidation zone._`);\n  }\n\n  // Net bias\n  const bullish = signals.filter(s => s.direction === 'bullish').reduce((a, s) => a + s.strength, 0);\n  const bearish = signals.filter(s => s.direction === 'bearish').reduce((a, s) => a + s.strength, 0);\n  const net = bullish - bearish;\n  const biasEmoji = net > 0.5 ? 'ðŸŸ¢' : net < -0.5 ? 'ðŸ”´' : 'ðŸŸ¡';\n  const biasLabel = net > 0.5 ? 'Bullish' : net < -0.5 ? 'Bearish' : 'Neutral';\n  lines.push(``);\n  lines.push(`${biasEmoji} **Net Bias: ${biasLabel}** (bull: ${bullish.toFixed(1)} / bear: ${bearish.toFixed(1)})`);\n\n  return lines.join('\\n');\n}\n\nmodule.exports = {\n  calculateSMA,\n  calculateEMA,\n  calculateRSI,\n  calculateMACD,\n  calculateBollingerBands,\n  calculateATR,\n  computeTechnicals,\n  detectSignals,\n  analyze,\n  formatForDiscord,\n};\n",
  "new_columns_added": [
    "DEBUG",
    "error_handling_fix"
  ]
}