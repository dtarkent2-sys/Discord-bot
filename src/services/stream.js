const Alpaca = require('@alpacahq/alpaca-trade-api');
const config = require('../config');\n\n// How large a 1-min bar % move must be to trigger an alert\nconst BIG_MOVE_PCT = 1.5;\n// Maximum symbols a single channel can subscribe to\nconst MAX_SUBS_PER_CHANNEL = 25;\n// Cooldown between big-move alerts for the same symbol (ms)\nconst ALERT_COOLDOWN_MS = 5 * 60 * 1000; // 5 min\n\nclass AlpacaStream {\n  constructor(discordClient) {\n    this.discord = discordClient;\n    this.alpaca = null;\n    this.socket = null;\n    this.connected = false;\n\n    // channelId â†’ Set<symbol>\n    this.channelSubs = new Map();\n    // symbol â†’ Set<channelId>  (reverse index for fast dispatch)\n    this.symbolChannels = new Map();\n\n    // symbol â†’ { open, high, low, close, volume, timestamp }\n    this.latestBars = new Map();\n    // symbol â†’ { price, timestamp }\n    this.latestTrades = new Map();\n    // symbol â†’ timestamp of last big-move alert\n    this.alertCooldowns = new Map();\n  }\n\n  // â”â”€ Lifecycle â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€\n\n  get enabled() {\n    return !!(config.alpacaApiKey && config.alpacaApiSecret);\n  }\n\n  connect() {\n    if (!this.enabled) {\n      console.warn('[Stream] Alpaca keys not set â€” WebSocket stream disabled.');\n      return;\n    }\n    if (this.socket) return; // already connected or connecting\n\n    this.alpaca = new Alpaca({\n      keyId: config.alpacaApiKey,\n      secretKey: config.alpacaApiSecret,\n      feed: config.alpacaFeed || 'iex',\n      paper: true,\n    });\n\n    this.socket = this.alpaca.data_stream_v2;\n\n    this.socket.onConnect(() => {\n      console.log('[Stream] Connected to Alpaca WebSocket.');\n      this.connected = true;\n\n      // Re-subscribe any symbols that were active before a reconnect\n      const allSymbols = [...this.symbolChannels.keys()];\n      if (allSymbols.length > 0) {\n        console.log(`[Stream] Re-subscribing to ${allSymbols.length} symbols...`);\n        this.socket.subscribeForTrades(allSymbols);\n        this.socket.subscribeForBars(allSymbols);\n      }\n    });\n\n    this.socket.onDisconnect(() => {\n      console.warn('[Stream] Disconnected from Alpaca WebSocket.');\n      this.connected = false;\n    });\n\n    this.socket.onError((err) => {\n      const msg = typeof err === 'string' ? err : err?.message || String(err);\n      // Only log unexpected errors â€” connection limit and auth issues are handled by reconnect\n      if (!msg.includes('connection limit') && !msg.includes('auth timeout')) {\n        console.error('[Stream] WebSocket error:', msg);\n      } else {\n        console.warn(`[Stream] WebSocket: ${msg} (will retry)`);\n      }\n    });\n\n    this.socket.onStateChange((state) => {\n      console.log(`[Stream] State: ${state}`);\n    });\n\n    // â”€â”€â”€â”€â”€ Data handlers â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€\n\n    this.socket.onStockTrade((trade) => {\n      this._handleTrade(trade);\n    });\n\n    this.socket.onStockBar((bar) => {\n      this._handleBar(bar);\n    });\n\n    this.socket.connect();\n    console.log('[Stream] Connecting to Alpaca WebSocket...');\n  }\n\n  disconnect() {\n    if (this.socket) {\n      this.socket.disconnect();\n      this.connected = false;\n      console.log('[Stream] WebSocket disconnected.');\n    }\n  }\n\n  // â”â”€ Subscription management â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€\n\n  /**\n   * Subscribe a Discord channel to one or more symbols.\n   * @param {string} channelId\n   * @param {string[]} symbols\n   * @returns {{ added: string[], already: string[], error?: string }}\n   */\n  subscribe(channelId, symbols) {\n    // Lazy-connect: start WebSocket on first subscription\n    if (!this.socket && this.enabled) {\n      this.connect();\n      // Give it a moment to connect â€” subscriptions will be queued by the SDK\n    }\n    if (!this.socket) {\n      return { added: [], already: [], error: 'WebSocket not available â€” check Alpaca API keys.' };\n    }\n\n    const channelSet = this.channelSubs.get(channelId) || new Set();\n    if (channelSet.size >= MAX_SUBS_PER_CHANNEL) {\n      const offending = [...symbols].slice(MAX_SUBS_PER_CHANNEL - channelSet.size);\n      return {\n        added: [],\n        already: [],\n        error: \`Channel limit reached (${MAX_SUBS_PER_CHANNEL} symbols max) for ${offending.join(', ')}. Split across channels or request multiple subscriptions.\`, \n      };\n    }\n\n    const added = [];\n    const already = [];\n    const newToSocket = []; // symbols not yet subscribed at the WS level\n\n    for (const raw of symbols) {\n      const sym = raw.toUpperCase();\n      if (channelSet.has(sym)) {\n        already.push(sym);\n        continue;\n      }\n      if (channelSet.size + added.length >= MAX_SUBS_PER_CHANNEL) break;\n\n      channelSet.add(sym);\n      added.push(sym);\n\n      // Update reverse index\n      if (!this.symbolChannels.has(sym)) {\n        this.symbolChannels.set(sym, new Set());\n        newToSocket.push(sym);\n      }\n      this.symbolChannels.get(sym).add(channelId);\n    }\n\n    this.channelSubs.set(channelId, channelSet);\n\n    // Subscribe new symbols at the WebSocket level\n    if (newToSocket.length > 0) {\n      this.socket.subscribeForTrades(newToSocket);\n      this.socket.subscribeForBars(newToSocket);\n      console.log(`[Stream] WS subscribed: ${newToSocket.join(', ')}`);\n    }\n\n    return { added, already };\n  }\n\n  /**\n   * Unsubscribe a Discord channel from one or more symbols.\n   * @param {string} channelId\n   * @param {string[]} symbols\n   * @returns {{ removed: string[], notFound: string[] }}\n   */\n  unsubscribe(channelId, symbols) {\n    const channelSet = this.channelSubs.get(channelId);\n    if (!channelSet) return { removed: [], notFound: symbols.map(s => s.toUpperCase()) };\n\n    const removed = [];\n    const notFound = [];\n    const removeFromSocket = [];\n\n    for (const raw of symbols) {\n      const sym = raw.toUpperCase();\n      if (!channelSet.has(sym)) {\n        notFound.push(sym);\n        continue;\n      }\n\n      channelSet.delete(sym);\n      removed.push(sym);\n\n      // Update reverse index\n      const channels = this.symbolChannels.get(sym);\n      if (channels) {\n        channels.delete(channelId);\n        if (channels.size === 0) {\n          this.symbolChannels.delete(sym);\n          removeFromSocket.push(sym);\n        }\n      }\n    }\n\n    if (channelSet.size === 0) this.channelSubs.delete(channelId);\n\n    // Unsubscribe symbols no longer watched by any channel\n    if (removeFromSocket.length > 0) {\n      this.socket.unsubscribeFromTrades(removeFromSocket);\n      this.socket.unsubscribeFromBars(removeFromSocket);\n      console.log(`[Stream] WS unsubscribed: ${removeFromSocket.join(', ')}`);\n    }\n\n    return { removed, notFound };\n  }\n\n  /**\n   * Get all symbols a channel is subscribed to.\n   * @param {string} channelId\n   * @returns {string[]}\n   */\n  getSubscriptions(channelId) {\n    const set = this.channelSubs.get(channelId);\n    return set ? [...set].sort() : [];\n  }\n\n  /**\n   * Get the latest price snapshot for a symbol (from stream data).\n   * @param {string} symbol\n   * @returns {{ price: number, timestamp: string } | null}\n   */\n  getLatestPrice(symbol) {\n    return this.latestTrades.get(symbol.toUpperCase()) || null;\n  }\n\n  /**\n   * Get the latest minute bar for a symbol.\n   * @param {string} symbol\n   * @returns {object|null}\n   */\n  getLatestBar(symbol) {\n    return this.latestBars.get(symbol.toUpperCase()) || null;\n  }\n\n  // â”â”€ Status â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€\n\n  getStatus() {\n    return {\n      connected: this.connected,\n      symbols: this.symbolChannels.size,\n      channels: this.channelSubs.size,\n      feed: config.alpacaFeed || 'iex',\n    };\n  }\n\n  // â”â”€ Internal event handlers â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€\n\n  _handleTrade(trade) {\n    const sym = trade.S;\n    this.latestTrades.set(sym, {\n      price: trade.p,\n      size: trade.s,\n      timestamp: trade.t,\n    });\n  }\n\n  _handleBar(bar) {\n    const sym = bar.S;\n    const prev = this.latestBars.get(sym);\n    const barData = {\n      open: bar.o,\n      high: bar.h,\n      low: bar.l,\n      close: bar.c,\n      volume: bar.v,\n      vwap: bar.vw,\n      timestamp: bar.t,\n    };\n    this.latestBars.set(sym, barData);\n\n    // Check for big move\n    if (prev && prev.close > 0) {\n      const pctChange = ((bar.c - prev.close) / prev.close) * 100;\n      if (Math.abs(pctChange) >= BIG_MOVE_PCT) {\n        this._maybeSendBigMoveAlert(sym, bar.c, prev.close, pctChange, bar.v);\n      }\n    }\n  }\n\n  async _maybeSendBigMoveAlert(symbol, price, prevClose, pctChange, volume) {\n    const now = Date.now();\n    const lastAlert = this.alertCooldowns.get(symbol) || 0;\n    if (now - lastAlert < ALERT_COOLDOWN_MS) return;\n\n    const channels = this.symbolChannels.get(symbol);\n    if (!channels || channels.size === 0) return;\n\n    this.alertCooldowns.set(symbol, now);\n\n    const direction = pctChange > 0 ? 'up' : 'down';\n    const emoji = pctChange > 0 ? 'ðŸŸ¢' : 'ðŸ”´';\n    const vol = volume ? ` | Vol: ${Number(volume).toLocaleString()}` : '';\n\n    const message = [\n      `${emoji} **${symbol}** moved ${direction} **${Math.abs(pctChange).toFixed(2)}%** in the last minute`,\n      `$${prevClose.toFixed(2)} â†’ **$${price.toFixed(2)}**${vol}`,\n    ].join('\\n');\n\n    for (const channelId of channels) {\n      try {\n        const channel = await this.discord.channels.fetch(channelId);\n        if (channel?.isTextBased()) {\n          await channel.send(message);\n        }\n      } catch (err) {\n        console.warn(`[Stream] Failed to send alert to ${channelId}:`, err.message);\n      }\n    }\n  }\n}\n\nlet instance = null;\n\nmodule.exports = {\n  /**\n   * Initialize the stream with a Discord client.  Call once on bot ready.\n   * @param {import('discord.js').Client} discordClient\n   * @returns {AlpacaStream}\n   */\n  init(discordClient) {\n    if (!instance) {\n      instance = new AlpacaStream(discordClient);\n    }\n    return instance;\n  },\n\n  /** @returns {AlpacaStream|null} */\n  getInstance() {\n    return instance;\n  },\n};" > src/services/stream.js